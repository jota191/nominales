\documentclass{article}

\usepackage{ amsmath }
\usepackage{ amssymb }

\newcommand\algRel{$\Rightarrow$}
\usepackage{ bussproofs }
\usepackage{ multicol }
\usepackage{ enumitem }

\newcommand\fresh[2]{
  \relax
  \ifmmode
      {#1 \# #2}
  \else
      {$#1 \# #2$}
  \fi}
\newcommand\eqa[2]{
  \relax
  \ifmmode
      {#1 \approx_{\alpha} #2}
  \else
      $#1 \approx_{\alpha} #2$
  \fi}

%time to do it the right way

\newcommand\mathize[1]{
  \relax
  \ifmmode
      {#1}
  \else
      {$#1$}
  \fi}

\newcommand\Ax{\AxiomC}
\newcommand\Bin{\BinaryInfC}
\newcommand\Una{\UnaryInfC}

\newcommand\RL{\RightLabel}

\newcommand\abs[2]{\mathize{[#1] #2}}
\newcommand\lam[2]{\lambda\abs{#1}{#2}}

\newcommand\labstw{\RL{abs2}}
\newcommand\lfsym{\RL{func sym}}


\newcommand\LHS{\textrm{LHS}}
\newcommand\RHS{\textrm{RHS}}

\newcommand{\doubl}[1]
           {\left\lVert#1\right\rVert}
           \newcommand{\simpl}[1]
                      {\left|#1\right|}

\begin{document}

\EnableBpAbbreviations



\section*{Problem 1}

\begin{multicols*}{2}
\subsection*{a)}

 \begin{prooftree}
  \AXC{\fresh{x}{y}}
  \AXC{\eqa{x}{x}}
  \UIC{\eqa{x}{(x \: y) \cdot y}}
  \BIC{\eqa{\abs{x}{x}}{\abs{y}{y}}}
  \UIC{\eqa{\lam{x}{x}}
          {\lam{y}{y}}}
\end{prooftree}

\subsection*{b)}

\begin{prooftree}
  \AXC{}
  \UIC{\fresh{x}{\abs{x}{y}}}
  \UIC{\fresh{x}{\lam{x}{y}}}
  \AXC{$\cdots$}
  \UIC{\eqa{{\lam{y}{x}}}{{\lam{y}{x}}}}
  \RightLabel{$\equiv$}
  \UIC{\eqa{{\lam{y}{x}}}{(x\: y) \cdot {\lam{x}{y}}}}
  \labstw
  \BIC{\eqa{\abs{x}{\lam{y}{x}}}{\abs{y}{\lam{x}{y}}}}
  \lfsym
  \UIC{\eqa{\lam{x}{\lam{y}{x}}}{\lam{y}{\lam{x}{y}}}}
\end{prooftree}

The incomplete branch here is trivial since both terms are sintactical
equivalent. They can be decomposed constructor by constructor. Note
that in the $\equiv$ ``rule'' there is no actual rule applied. A
permutation applied to a ground term is actually sintactically equal
to the result, there is no suspention here. We adopt this syntax to
make the applied permutation explicit, for clarity.

\subsection*{c)}
\subsection*{d)}

\begin{prooftree}
  \AXC{?}
  \UIC{\fresh{x}{Y}}
  \AXC{?}
  \UIC{\eqa{X}{(x\: y) \cdot Y}}
  \BIC{\eqa{\abs{x}{X}}{\abs{y}{Y}}}
  \UIC{\eqa{\lam{x}{X}}{\lam{y}{Y}}}
\end{prooftree}

\subsection*{e)}

\begin{prooftree}
  \AXC{\fresh{x}{X}}
  \AXC{\fresh{x}{X}}
  \AXC{?}
  \UIC{\fresh{y}{X}}
  \BIC{\eqa{X}{(x\: y) \cdot X}}
  \BIC{\eqa{\abs{x}{X}}{\abs{y}{X}}}
  \UIC{\eqa{\lam{x}{X}}{\lam{y}{X}}}
\end{prooftree}

\subsection*{f)}
\begin{prooftree}
  \AXC{\fresh{x}{s(X)}}
  \AXC{\fresh{x}{X}}
  \AXC{}
  \UIC{\fresh{y}{X}}
  \BIC{\eqa{X}{(x\: y) \cdot X}}
  \UIC{\eqa{s(X)}{s((x\: y) \cdot X)}}
  \UIC{\eqa{s(X)}{(x\: y) \cdot s(X)}}
  \BIC{\eqa{\abs{x}{s(X)}}{\abs{y}{s(X)}}}
  \UIC{\eqa{\lam{x}{s(X)}}{\lam{y}{s(X)}}}
\end{prooftree}


\end{multicols*}


\newpage

\section*{Excercise 3}

This is a nontrivial proof of temination since the (\algRel) relation
is not defined inductively. {TODO: REF PAPERS }

A common tool for proving the termination of programs (or, of course
rewriting systems) is to find an strictly decreasing termination
function that maps the state of the program into some
\emph{well-founded} set. For this excercise we use multiset orderings.
A nice introductory paper like \cite{DBLP:conf/icalp/DershowitzM79}.

The idea is that given a base order ($\prec$) over a set $A$, we
define an order $\prec_{\mathscr{P}}$ over finite multisets of $A$
where $A \prec_{\mathscr{P}} B$ if and only if we can get $A$ from $B$
substituting zero or more elements, each by a finite set of smaller
elements (according to $\prec$).  It is well known, and easy to prove
(details in \cite{DBLP:conf/icalp/DershowitzM79}) that
($\prec_{\mathscr{P}}$) is a well-founded order whenever ($\prec$) is
a well-founded order.

For the (\algRel) relation we have a total of 12 rules (six rewriting
freshness relations, as many rewriting $\alpha$equivalence
predicates). Lets name them as: \hfill\break $\#_1, \#_2, \#_3, \#_4,
\#_5, \#_6,\alpha_1, \alpha_2, \alpha_3, \alpha_4, \alpha_5,
\alpha_6$. When a rule is of the form $Pr \Rightarrow Pr'$ we refer
$Pr$ and $Pr'$ as LHS and RHS.

If we define some notion of size ($sz$) for $\fresh{a}{t}$ and
$\eqa{t}{u}$ and then:

$$size(Pr) = \bigcup_{p \in Pr} sz(p) $$

\noindent
It is clear that for $\#1$, $\#5$, and $\alpha_1$, $size$ is
decreasing from LHS to RHS since $size (\LHS) \subset size(\RHS)$, and
if $A \subseteq B$ then $A \prec_{\mathsc{P}} B$ in the multiset
ordering.

For most of the other rules $size$ is also decreasing if $sz$ is
monotone with respect to the structure of the terms used in the
predicates. But note that ($\#_6$) requires $sz(\fresh{a}{\pi \cdot
  X}) > sz(\fresh{a}{id \cdot X})$ (when $\pi \neq id$) and in the
other hand ($\alpha_5$) introduces a permutation, generating possibly
many suspentions, which means that it is not clear that
$size(\eqa{\abs{b}{l}}{\abs{a}{s}}) > size(\eqa{(a \: b) \cdot
  l}{s})$. Also, rules ($\alpha_5$) and ($\alpha_6$) suggest that it
is a good idea to consider equivalence conditions ``bigger'' than
freshness conditions.

Taking all this into account, the following $sz$ function is
proposed:

\begin{align*}
  sz(\fresh{a}{t}) &= (1, \doubl{t})\\
  sz(\eqa{t}{u}) &= (2, \simpl{\eqa{t}{u}})
\end{align*}

where:

\begin{align*}
  
\end{align*}


\bibliographystyle{alpha}
\bibliography{bib}

\end{document}
